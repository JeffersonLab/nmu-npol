//
// ********************************************************************
// * License and Disclaimer                                           *
// *                                                                  *
// * The  Geant4 software  is  copyright of the Copyright Holders  of *
// * the Geant4 Collaboration.  It is provided  under  the terms  and *
// * conditions of the Geant4 Software License,  included in the file *
// * LICENSE and available at  http://cern.ch/geant4/license .  These *
// * include a list of copyright holders.                             *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.  Please see the license in the file  LICENSE  and URL above *
// * for the full disclaimer and the limitation of liability.         *
// *                                                                  *
// * This  code  implementation is the result of  the  scientific and *
// * technical work of the GEANT4 collaboration.                      *
// * By using,  copying,  modifying or  distributing the software (or *
// * any work based  on the software)  you  agree  to acknowledge its *
// * use  in  resulting  scientific  publications,  and indicate your *
// * acceptance of all terms of the Geant4 Software license.          *
// ********************************************************************
//
//
// $Id: EventAction.cc,v 1.11 2006/06/29 17:48:05 gunter Exp $
// GEANT4 tag $Name: geant4-09-03-patch-01 $
//
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
 
#include "EventAction.hh"

#include "G4Event.hh"
#include "G4EventManager.hh"
#include "G4TrajectoryContainer.hh"
#include "G4Trajectory.hh"
#include "G4ios.hh"

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
 
EventAction::EventAction()
{
  fp=fopen("g4Npol7000.out","w");
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
 
EventAction::~EventAction()
{}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
 
void EventAction::BeginOfEventAction(const G4Event*)
{}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
 
void EventAction::EndOfEventAction(const G4Event* evt)
{
  G4int event_id = evt->GetEventID();
  
  // get number of stored trajectories
  //
  G4TrajectoryContainer* trajectoryContainer = evt->GetTrajectoryContainer();
  G4int n_trajectories = 0;
  if (trajectoryContainer) n_trajectories = trajectoryContainer->entries();
  
  // periodic printing
  //
  if (event_id < 100 || event_id%100 == 0) {
    G4cout << ">>> Event " << evt->GetEventID() << G4endl;
    G4cout << "    " << n_trajectories 
	   << " trajectories stored in this event." << G4endl;
  }
/*
  for( G4int i=0; i<n_trajectories; i++ ) {
        G4Trajectory* track =
          (G4Trajectory*)( *(evt->GetTrajectoryContainer()) )[i];
        track->ShowTrajectory();
        G4cout << G4endl;
  }
*/ 
  G4double energy[11] = {10.0, 20.0, 40.0, 100.0, 200.0, 300.0,
                         400.0, 500.0, 600.0, 800.0, 1000.0};
  G4double eLoss[11] = {47.21, 26.82, 15.25, 7.44, 4.58, 3.59, 
                        3.09, 2.79, 2.60, 2.37, 2.24}; 
  
  G4double initEK=0.0;
  G4double kineEProton=-1.0;
  G4double eLossProton=-1.0;

  G4double xLength = 1.016*m;
  G4double yLength = 0.6*1.016*m; 
/* pac35 
  G4double zTop = 0.25*m;
  G4double yTop = 1.0*m;
  G4double topXLength = 1.25*m;
  G4double topZLength = 2.032*m;
*/
  G4double zTop = 1.0*m;
//  G4double yTop = 1.5*m;
  G4double yTop = 0.7*m;
  G4double topXLength = 1.016*m;
  G4double topZLength = 5.437*m; 
  G4double halfWidth = 0.0508*m;
//  G4double halfThinWidth = 0.005*m;
// pac35
//  G4double zScint[6] = {-0.7*m, -0.4*m, -0.1*m, 0.2*m, 0.5*m, 0.8*m};
//  G4double zScint[6] = {-1.70*m, -1.00*m, -0.30*m,
//                         0.40*m,  1.10*m, 1.80*m};

  G4double zScint[6];
  for(G4int i = 0; i < 6; i++)
          zScint[i] = (-1.6992 + 0.70*i)*m;


  G4bool reachRear = false;   //reach top Y > yTop - halfWidth
  G4bool escape = false;      // proton not stopped in 1st scint
  G4bool multScint = false;   // proton reach neighbor scint
  G4bool missX = false;       // exceed X boundary of Top
  G4bool missZ = false;       // exceed Y boundary of Top

  G4String text = "Stopped";
  G4int iScint = -1;

// three points of a track, 0: init, 1: point escaped from 1st scint 
// 2: first point in Top or last point of the track
  G4double xStep[3] = {0., 0., 0.};  
  G4double yStep[3] = {0., 0., 0.};  
  G4double zStep[3] = {0., 0., 0.};

// flight path, 0: from point of step[0] to step[1], 1: from step[1] to step[2]
  G4double fpath[2] = {0., 0.};

  fprintf(fp,"Event %d has %d tracks\n", evt->GetEventID(),n_trajectories);
  for( G4int i=0; i<n_trajectories; i++ ) {
        G4Trajectory* track =
          (G4Trajectory*)( *(evt->GetTrajectoryContainer()) )[i];
          G4String particleName = track->GetParticleName();

// proton beam only
          if ( particleName == "neutron" && track->GetParentID() == 0 ) {
            initEK = track->GetInitialKineticEnergy(),

            fprintf(fp," %8.2f %8.2f %8.2f %8.2f\n",
            track->GetInitialMomentum().mag(),
            initEK,
            track->GetInitialMomentum().theta()/deg,
            track->GetInitialMomentum().phi()/deg);

// check points     
            for(G4int j = 0; j < track-> GetPointEntries(); j++) {
              G4VTrajectoryPoint *point  = track->GetPoint(j);
// init point
              if(j == 0) {
                  xStep[0] = point->GetPosition().x();
                  yStep[0] = point->GetPosition().y();
                  zStep[0] = point->GetPosition().z();
                  for(G4int ii = 0; ii < 6; ii++) {
                    if(zScint[ii] - halfWidth <= zStep[0] && 
                       zStep[0] < zScint[ii] + halfWidth) {
                         iScint = ii;
                         break;
                    }
                  }
      
              fprintf(fp,"     %d %7.1f %7.1f %7.1f\n",
                         iScint,xStep[0],yStep[0],zStep[0]);
 
              }
// check if reaching neighbor scint
              else {
                if(iScint < 5) {
                  if(fabs(point->GetPosition().y()) <= 0.5*yLength &&
                     fabs(point->GetPosition().z() - zScint[iScint+1]) < 
                                                         halfWidth){
                   multScint = true;  
                  }
                }
 
// proton not stopped, save info of this point 
                if(!escape) { 
                  if(point->GetPosition().z() > zScint[iScint] + halfWidth ||
                     fabs(point->GetPosition().y()) > 0.5*yLength ||
                     fabs(point->GetPosition().x()) > 0.5*xLength) {
                     escape = true;
                     xStep[1] = point->GetPosition().x();
                     yStep[1] = point->GetPosition().y();
                     zStep[1] = point->GetPosition().z();
                                                                                
                  }

/*
                  else {
                     xStep[1] = 0.;
                     yStep[1] = 0.;
                     zStep[1] = 0.;
                  }
*/
                }
              } 

// Y of point higher enough to cross Top 
              if(point->GetPosition().y() > yTop - halfWidth) { 
                if (!reachRear) {
                  reachRear = true; 
                  xStep[2] = point->GetPosition().x();
                  yStep[2] = point->GetPosition().y();
                  zStep[2] = point->GetPosition().z();
                } 
              }

// Check X,Z bounadry 
              else {
                if(fabs(point->GetPosition().x()) > 0.5*topXLength) 
                                                  missX = true;
                if(point->GetPosition().z() > 0.5*topZLength + zTop) 
                                                         missZ = true;
                
// last point
                if(j == track-> GetPointEntries() - 1) {
                  xStep[2] = point->GetPosition().x();
                  yStep[2] = point->GetPosition().y();
                  zStep[2] = point->GetPosition().z();
                }
              }
                    
            }

// calcluate flight path and energy loss
            for(G4int k = 0; k < 2; k++) {
              if((k == 0 && escape) || k == 1)  {
              fpath[k] = sqrt( (xStep[k+1]-xStep[0]) * (xStep[k+1]-xStep[0])
                             +(yStep[k+1]-yStep[0]) * (yStep[k+1]-yStep[0])
                             +(zStep[k+1]-zStep[0]) * (zStep[k+1]-zStep[0]));
                if(k == 0) {
                  if(initEK < energy[0]) 
                    eLossProton = 0.1*fpath[k] * eLoss[0];
                  else if (initEK >= energy[10]) 
                    eLossProton = 0.1*fpath[k] * eLoss[10];
                  else {
                    for(G4int l = 0; l < 10; l++) {
                      if(energy[l] <= initEK && initEK < energy[l+1]) {
                        eLossProton = 0.1*fpath[k] * (eLoss[l+1] + 
                           (eLoss[l] - eLoss[l+1]) * 
                           (energy[l+1] - initEK)/(energy[l+1] - energy[l]));
/*
                        fprintf(fp,"\t\t %9.3f %9.3f %9.3f %9.3f %9.3f\n", 
                        initEK, eLoss[l], eLoss[l+1], energy[l], energy[l+1]);
                        fprintf(fp,"\t\tEnergy loss = %9.3f\n", eLossProton);
*/
                        break;
                      }
                    }
                  }
                }
              }
              
            }

// determin event type from vaiables of G4bool  
            if(escape){
              if (reachRear) {
                if(!missX && ! missZ) text = "Detected";
                else if(missX && !missZ) text = "MissX";
                else if(!missX && missZ) text = "MissZ";
                else text = "MissXZ"; 
              }
              else if (multScint) {
                  if (!missX && !missZ ) text = "Absorbed";
                  else text = "Passed";
              }
              else text = "Others";
            }

// output
            fprintf(fp,"       %7.1f %7.1f %7.1f %8.2f %d\n",
            xStep[1],yStep[1],zStep[1],fpath[0], escape);
            if(escape && reachRear)
              kineEProton = initEK - eLossProton;
            else kineEProton = 0.0;

            fprintf(fp,
             "       %7.1f %7.1f %7.1f %8.2f % 8.2f %8.2f %d %d %d %d %d %s\n",
              xStep[2],yStep[2],zStep[2],fpath[1], 
              eLossProton, kineEProton, escape, reachRear, multScint, 
              missX, missZ, text.data());
          }
    } 
                                                                                


}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
